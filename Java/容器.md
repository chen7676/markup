# 容器

## 集合框架

集合框架被设计成要满足以下几个目标。

- 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。
- 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。
- 对一个集合的扩展和适应必须是简单的。

为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： **LinkedList**, **HashSet**, 和 **TreeSet** 等,除此之外你也可以通过这些接口实现自己的集合。

集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：

- **接口：**是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象
- **实现（类）：**是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。
- **算法：**是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。

除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。

![container](images/container.gif)

## Collection接口

collection接口位于`java.util`中，它所存储的元素的特点 是不唯一(`List`接口)和无序(`Set`接口)的。

- 定义

```java
public interface Collection<E> extends Iterable<E>
```

collection接口继承了Iterable接口，说明集合框架具有一种能力，即可以使用加强for循环便利集合中元素对象的能力。

- 常用方法

| 执行操作 | 返回值类型  | 方法名                             | 描述                                     |
| -------- | ----------- | ---------------------------------- | ---------------------------------------- |
| add      | boolean     | `add(E e)`                         | 向集合中添加一个对象                     |
| add      | boolean     | `addAll(Collection<?extends E> c)` | 将一个集合的元素一次性添加到另一个集合中 |
| judge    | boolean     | `isEmpty()`                        | 判断集合是否为空，即集合的长度为0        |
| judge    | boolean     | `contains(Object o)`               | 判断指定对象在集合中是否存在             |
| judge    | boolean     | `equals(Object o)`                 | 用于比较集合中的玉安素是否完全相同       |
| delete   | boolean     | `remove(Object o)`                 | 一次删除一个对象                         |
| delete   | boolean     | `clear()`                          | 一次性删除集合中的全部对象               |
| delete   | void        | `removeAll(Collection<?> c)`       | 将两个集合中相同的对象删除               |
| delete   | boolean     | `retianAll(Collection<?> c)`       | 将两个集合中不通的对象删除               |
| select   | Iterator<E> | `iterator()`                       | 返回在此集合的元素上进行迭代的迭代器     |
| select   | int         | `size()`                           | 返回集合中元素的个数                     |

实现

```java
import java.util.ArrayList;
import java.util.Collection;


public class TestCollection {
    public static void main(String[] args) {
        Collection col1 = new ArrayList();// 多台，接口去new实现类，向上类型转换
        // add
        System.out.println("添加元素之前，集合是否为空：" + col1.isEmpty());
        col1.add(123); // jdk1.5之后自动装箱，相当于Object o = new Integer(123)
        col1.add("helloworld"); // 相当于Object o = new String("helloworld")
        // isEmpty
        System.out.println("添加元素之后，集合是否为空：" + col1.isEmpty());
        System.out.println("集合中元素的个数是：" + col1.size());
        // addAll
        Collection col2 = new ArrayList();
        col2.add("java");
        col2.add("html");
        col2.add("sql");
        col1.addAll(col2);
        System.out.println("集合中元素为：" + col1.toString());
        // contains,containsAll
        System.out.println("java在col1集合中是否存在："+col1.contains("java"));
        System.out.println("col1中是否包含col2中的全部元素："+ col1.containsAll(col2));
        // equlas
        System.out.println("col1是否合col2相等："  + col1.equals(col2));
        // remove
        System.out.println("删除java：" + col1.remove("java"));
        // clear
        System.out.println("删除所有：");
        col1.clear();
        // 删除col1和col2中相交的元素
        col1.removeAll(col2);
        System.out.println("coll.removeAll(col2) col1:" + col1);
        System.out.println("coll.removeAll(col2) col2:" + col2);
        // 删除将col1和col2中不相交的元素
        col1.retainAll(col2);
        System.out.println("coll.retainAll(col2) col1:" + col1);
        System.out.println("coll.retainAll(col2) col2:" + col2); 
    }
}
```

- 遍历

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class TestCollection2 {
    public static void main(String[] args) {
        Collection col1 = new ArrayList<>(); // 多台，接口去new实现类，向上类型转换
        col1.add("java"); // 向上类型转换，相当于Object o = new String("java")
        col1.add("html");
        col1.add("sql");
        // 加强for循环
        System.out.println("使用加强for循环");
        for (Object o : col1) {
            System.out.println(o + "\t");
        }
        // iterator
        System.out.println("使用iterator");
        Iterator it = col1.iterator();
        while (it.hasNext()) {
            Object o = it.next();
            System.out.println(o + "\t");
        }
        // 另外写法
        System.out.println("for循环中使用iterator");
        for (Iterator it1 = col1.iterator(); it1.hasNext();) {
            System.out.println(it1.next() + "\t");
        }
        System.out.println("\n");
    }
}
```

## List接口

List接口位于`java.util`包中，是`Collection`接口的子接口，用于存储一组有序 的不唯一的元素对象，有序指的是元素的添加顺序。

- 常用方法

| 操作类型 | 返回值类型 | 方法名                                       | 描述                                               |
| -------- | ---------- | -------------------------------------------- | -------------------------------------------------- |
| add      | void       | `add(int index, E element)`                  | 在指定位置上添加一个元素                           |
| add      | boolean    | `addAll(int index, Collection<?extends E>c)` | 在指定位置上添加一批元素                           |
| delete   | E          | `remove(int index)`                          | 先将集合中指定位置上的元素取出，然后再将改元素删除 |
| update   | E          | `set(int index, E element)`                  | 用指定元素替换集合中指定位置上的元素               |
| update   | `List<E>`  | `subList(int fromIndex, int. toIndex)`       | 截取子集合，含头不含尾                             |
| select   | E          | `get(int index)`                             | 获取指定位置上的元素，但不删除                     |
| select   | `List<E>`  | `listIterator()`                             | 返回此列表元素列表迭代器                           |

实现

```java
import java.util.ArrayList;
import java.util.List;

public class TestList {
    public static void main(String[] args) {
        List list1 = new ArrayList<>();
        // add
        list1.add("java");
        list1.add("html");
        System.out.println(list1);
        list1.add(0, "sql");
        System.out.println(list1);
        // addAll
        List list2 = new ArrayList<>();
        list2.add("haha");
        list2.add("hello");
        list1.addAll(list1);
        System.out.println(list1);
        // remove， 返回被删除的元素
        System.out.println("remove(2)" + list1.remove(2));
        System.out.println(list1);
        // get
        System.out.println(list1.get(1));
        System.out.println(list1);
        // set, 返回被替换的元素
        System.out.println("set('hehe')" + list1.set(2, "hehe"));
        System.out.println(list1);
        // subList
        List list3 = list1.subList(1, 3);
        System.out.println(list3);

    }
}
```

- 接口实现的类

`List`接口的常用实现类有`ArrayList, LinkedList,Vector`

**ArrayList**

`ArrayList`类位于`java.util`包中，继承`AbstractList`类实现的`List`接口，底层采用的数据结构是数组，允许添加重复的元素，并且添加的元素是有序的，按照添加顺序进行存储。优点是遍历元素和随机访问元素的效率比较高，而由于底层数据结构是数组，所以添加 、删除元素的效率比较低，因为插入元素和删除元素需要前后移动元素的位置。该类从JDK1.2开始，是线程不同步的，在多线程同时访问时，可以提高访问的效率，但同时会降低访问的安全性。

**Vector**

`Vector`类也位于`java.util`包中，也是继承`AbstractList`类实现的`List`接口，底层采用的数据结构是数组。该类从JDK1.0开始，是线程同步的，在多线程同时访问时，会降低访问的效率，但同时会提高访问的安全性。

`ArrayList,Vector`两者在添加删除遍历元素的方式均相同，但是需要运行效率较高时使用`ArrayList`，需要安全性较高时使用`Vector`

**LinkedList**

`LinkedList`类位于`java.util`包中，继承`AbstractSequentialList`类，实现`List`接口与`Dque`接口，存储的元素可重复而且是按添加顺序进行存储，底层的数据结构采用的是链表，优点是插入和删除元素的效率比较高。

在`list`基础上扩展的方法

| 执行操作 | 方法                      | 描述                                                     |
| -------- | ------------------------- | -------------------------------------------------------- |
| add      | `void addFirst(E e)`      | 在列表的开头插入指定元素                                 |
| add      | `void addLast(E e)`       | 将指定元素添加到列表的末尾                               |
| add      | `boolean offerFirst(E e)` | 在列表的开头插入指定元素                                 |
| add      | `boolean offerLast(E e)`  | 将指定元素添加到列表的末尾                               |
| delete   | `E removeFirst()`         | 先将列表中的第一个元素获取，然后再将该元素从列表中删除   |
| delete   | `E removeLast()`          | 先将列表中的最后一个元素获取，然后再将改元素从列表中删除 |
| delete   | `E pollFitst()`           | 先将列表中的第一个元素获取，然后再将该元素从列表中删除   |
| delete   | `E PollLast()`            | 先将列表中的最后一个元素获取，然后再将改元素从列表中删除 |
| select   | `E getFirst()`            | 获取列表中的第一个元素，但不删除                         |
| select   | `E getLast()`             | 获取列表中的最后一个元素，但不删除                       |
| select   | `E peekFirst()`           | 获取列表中的第一个元素，但不删除                         |
| select   | `E peekLast()`            | 获取列表中的最后一个元素，但不删除                       |

实现

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Vector;
import java.util.List;


public class TestLinkedList {
    public static void main(String[] args) {
        // 创建对象
        LinkedList lList = new LinkedList<>();
        Iterator i = lList.iterator();
        List l = new ArrayList();
        List l2 = new Vector();
        // 添加
        lList.add("hello");
        lList.addFirst("java");
        lList.addLast("world");
        lList.offerFirst("html");
        lList.offerLast("sql");
        System.out.println(lList);
        // 获取
        System.out.println(lList.getFirst());  // empty时报异常
        System.out.println(lList.getLast());
        System.out.println(lList.peekFirst());  // empty时输出null
        System.out.println(lList.peekLast());
        // 删除
        System.out.println(lList.removeFirst()); // empty时异常
        System.out.println(lList.removeLast());
        System.out.println(lList.pollFirst());  // empty时输出null
        System.out.println(lList.pollLast());
        System.out.println(lList);
    }
}
```

## 泛型

在向集合中添加 元素是，元素类型进行了向上转型，任何类型都转换成了`Object`类型并添加到了集合中，而在遍历集合中元素时，使用了向下转型，转换成了`String`类型，所以这时出现了类型转换异常

```java

```



## 迭代器

## Set接口

## Map接口

## 集合工具类Collections

## 数组与集合的相互转换



